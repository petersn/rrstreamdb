import os
import json
import time
import hmac
import hashlib
import threading
import asyncio
import contextlib
import argparse
from typing import Tuple, List, Dict, Any

import websockets

def make_auth_token(
    role: str,
    expire_seconds: int,
    hmac_secret: str,
) -> str:
    assert role in ("r", "rw", "admin")
    random_component = os.urandom(8).hex()
    claim = "%s.%i.%s" % (role, int(time.time() + expire_seconds), random_component)
    tag = hmac.new(key=hmac_secret.encode(), msg=claim.encode(), digestmod="sha256").hexdigest()[:32]
    return f"{claim}-{tag}"


class StreamDBError(Exception):
    pass


class StreamDB:
    def __init__(self, ws):
        self.ws = ws
        self.future_table = {}
        self.request_token = 0

    @classmethod
    async def connect(cls, url: str, auth_token: str):
        this = cls(await websockets.connect(url))
        await this.ws.send(auth_token)
        msg = json.loads(await this.ws.recv())
        if msg["kind"] == "error":
            raise StreamDBError(message["message"])
        else:
            assert msg["kind"] == "auth"
        asyncio.create_task(this._pump_fiber())
        return this

    async def close(self):
        await self.ws.close()

    async def _pump_fiber(self):
        while True:
            try:
                message = json.loads(await self.ws.recv())
            except websockets.exceptions.ConnectionClosed:
                break
            if "token" not in message:
                print("WEIRD:", message)
            elif message["token"] in self.future_table:
                fut = self.future_table.pop(message["token"])
                if message["kind"] == "error":
                    fut.set_exception(StreamDBError(message["message"]))
                else:
                    fut.set_result(message)

    def _make_future(self) -> Tuple[int, asyncio.Future]:
        self.request_token += 1
        fut = asyncio.Future()
        self.future_table[self.request_token] = fut
        return self.request_token, fut

    async def _send(self, obj):
        await self.ws.send(json.dumps(obj))

    async def get_schema(self):
        token, fut = self._make_future()
        await self._send({
            "kind": "getSchema",
            "token": token,
        })
        response = await fut
        return {"tables": response["tables"], "subscriptions": response["subscriptions"]}

    async def append(self, table: str, row: Dict[str, Any]):
        token, fut = self._make_future()
        await self._send({
            "kind": "append",
            "token": token,
            "table": table,
            "row": row,
        })
        return await fut

    async def append_batch(self, table: str, rows: Dict[str, List[Any]]):
        token, fut = self._make_future()
        await self._send({
            "kind": "appendBatch",
            "token": token,
            "table": table,
            "rows": rows,
        })
        return await fut

    def append_batch_transpose(self, table: str, rows: List[Dict[str, Any]]):
        rows = {field: [] for field in rows[0]} if rows else {}
        for row in rows:
            for field, value in row.items():
                rows[field].append(value)
        return self.append_batch(table, rows)

    async def query(
        self,
        subscription: str,
        cursor: int = 0,
        groups: Dict[Any, int] = {},
        limit: int = -1,
    ) -> asyncio.Future:
        token, fut = self._make_future()
        await self._send({
            "kind": "query",
            "token": token,
            "subscription": subscription,
            "cursor": cursor,
            "groups": list(groups.items()),
            "limit": limit,
        })
        return (await fut)["rows"]


def generate_tsx(schema) -> str:
    typescript_mapping = {
        "Text": "string",
        "Float": "number",
        "Integer": "number",
        "Boolean": "boolean",
        "NullableText": "string | null",
        "NullableFloat": "number | null",
        "NullableInteger": "number | null",
        "NullableBoolean": "boolean | null",
        "JSON": "any",
    }
    tsx_subscription_template = (
        "export class Subscriptions {\n"
        "%s"
        "\n"
        "  constructor() { }\n"
        "\n"
        "  updateForMessage(message: any): boolean {\n"
        "    switch (message.kind) {\n"
        "%s"
        "      default: return false;\n"
        "    }\n"
        "    return true;\n"
        "  }\n"
        "}\n"
    )
    output = []
    output.append("// Automatically generated by streamdb.py --generate-tsx\n\n")
    for table_name, table_desc in schema["tables"].items():
        output.append("export interface %sRecord {\n  id: number;\n  created_at: string;\n" % table_name)
        for field_name, field_type in table_desc["fields"].items():
            if isinstance(field_type, list):
                t = " | ".join(map(repr, field_type))
            elif field_type in typescript_mapping:
                t = typescript_mapping[field_type]
            else:
                assert False, "Bad schema"
            output.append(f"  {field_name}: {t};\n")
        output.append("}\n\n")

    sub_fields = []
    sub_aggregation = []
    for table_name, table_desc in schema["tables"].items():
        if "subscription" in table_desc:
            sub_kind = table_desc["subscription"]["kind"]
            # index_by_username = table_desc["subscription"].get("index-by-username")
            index_by_username = False
            sub_aggregation.append("      case %r: {\n" % table_name)
            if sub_kind == "all":
                sub_fields.append(f"  sub{table_name}: Map<number /* id */, {table_name}Record> | null = null;\n")
                sub_aggregation.append(f"        if (this.sub{table_name} === null)\n")
                sub_aggregation.append(f"          this.sub{table_name} = new Map();\n")
                sub_aggregation.append(f"        for (const row of message.data)\n")
                sub_aggregation.append(f"          this.sub{table_name}.set(row.id, row);\n")
            elif sub_kind == "most-recent" or (sub_kind == "most-recent-by" and index_by_username):
                sub_fields.append(f"  sub{table_name}: {table_name}Record | null = null;\n")
                sub_aggregation.append(f"        for (const row of message.data)\n")
                if index_by_username:
                    sub_aggregation.append(f"        if (row.username === this.username)\n")
                    sub_aggregation.append("  ")  # Indent the next line for the if.
                sub_aggregation.append(f"          this.sub{table_name} = row;\n")
            elif sub_kind in ("most-recent-by", "stream"):
                if sub_kind == "stream" and "by" not in table_desc["subscription"]:
                    # stream subscriptions with no by field implicitly store by the ID on the client side.
                    group_by = "id"
                    by_type = "number"
                else:
                    group_by = table_desc["subscription"]["by"]
                    by_type = typescript_mapping[table_desc["fields"][group_by]]
                sub_fields.append(
                    f"  sub{table_name}: Map<{by_type} /* {group_by} */, {table_name}Record> | null = null;\n"
                )
                sub_aggregation.append(f"        if (this.sub{table_name} === null)\n")
                sub_aggregation.append(f"          this.sub{table_name} = new Map();\n")
                sub_aggregation.append(f"        for (const row of message.data)\n")
                sub_aggregation.append(f"          this.sub{table_name}.set(row.{group_by}, row);\n")
            else:
                assert False, f"Bad schema: {sub_kind}"
            sub_aggregation.append("        break;\n")
            sub_aggregation.append("      }\n")
    output.append(tsx_subscription_template % ("".join(sub_fields), "".join(sub_aggregation)))
    return "".join(output)


argument_parser = argparse.ArgumentParser()
argument_parser.add_argument(
    "--config",
    metavar="PATH",
    type=str,
    default="streamdb-config.yaml",
    help="Config file to load",
)
argument_parser.add_argument(
    "--auth-token-role",
    metavar="ROLE",
    type=str,
    help="Role for the generated auth token, one of: r rw admin",
)
argument_parser.add_argument(
    "--auth-token-expire-seconds",
    metavar="N",
    type=int,
    default=3600 * 24 * 180,
    help="Number of seconds the auth token is valid for (default: 180 days)",
)
argument_parser.add_argument(
    "--generate-tsx",
    metavar="PATH",
    type=str,
    help="Output a .tsx file corresponding to the schema",
)

if __name__ == "__main__":
    import yaml

    args = argument_parser.parse_args()
    with open(args.config) as f:
        config = yaml.safe_load(f)
    if args.generate_tsx is not None:
        output = generate_tsx(config)
        with open(args.generate_tsx, "w") as f:
            f.write(output)
    elif args.auth_token_role is not None:
        auth_token = make_auth_token(
            args.auth_token_role,
            args.auth_token_expire_seconds,
            config["hmacSecret"],
        )
        print(auth_token)
    else:
        argument_parser.print_help()
        exit(1)

#hmac_secret = "aafcb3d0a44b1af3a0d4da209ba98b88"
#auth_token = make_auth_token("rw", 3600, hmac_secret)
#
#async def main():
#    import pprint
#    stream_db = await StreamDB.connect("ws://localhost:10203/ws", auth_token)
#    schema = await stream_db.get_schema()
#    pprint.pprint(schema)
#    r = await stream_db.append("JobStatus", {"job_id": 1, "status": "active"})
#    print(r)
#    results = await stream_db.query("Foo", cursor=10)
#    print("RESULTS:", results)
#    await stream_db.close()
#
#asyncio.run(main())

#conn = StreamDB.connect("ws://localhost:10203/ws", auth_token)
#fut = conn.query("Foo")
